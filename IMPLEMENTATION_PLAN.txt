Implementation Plan: Codex JSONL Session Browser + Viewer (Option 1: Local Server)

Summary
- Add a local API to the Vite dev server that can read a configurable sessions folder (default: ~/.codex/sessions).
- Add a left sidebar for session browsing and search; keep sessions separate.
- Parse JSONL into per-turn groups. Default view shows thoughts and tools inline; both are toggleable.
- Add SQLite indexing + full-text search across user/assistant messages.
- Render message content with react-markdown + code highlighting and add per-message copy buttons (text + markdown).
- Expand the conversation container width.

Goals
- Browse Codex sessions stored on disk without manual copy/paste.
- Open a single session and render its conversation grouped by turn.
- Show thoughts and tools inline, with toggles to hide/show them.
- Provide fast search across all conversations (e.g. searching "react-markdown" finds the relevant session).
- Render message content as Markdown and support copy-as-text and copy-as-markdown per message.

Non-goals (for initial implementation)
- Packaged desktop app (Tauri/Electron) or a production server.
- Background sync across machines.

Constraints and Context
- Browser-only apps cannot read arbitrary local file paths without user prompts; a local server is required.
- Vite dev server can host an API middleware so only one process is required.
- Session files live under ~/.codex/sessions/YYYY/MM/DD/*.jsonl and are already chronological.

Data Inputs (JSONL Line Types Observed)
- Top-level "type" is a discriminator. Common examples:
  - "session_meta": session metadata, git info, repo, cli_version, etc.
  - "turn_context": per-turn context (cwd, model, instructions, policies, etc.)
  - "event_msg": conversational events like user_message, agent_message, agent_reasoning, token_count
  - "response_item": structured items including tool calls, tool outputs, messages, reasoning

Key Parsing Rules (Important to avoid duplicates)
1) Use event_msg as the primary source for conversational content:
   - event_msg payload.type == user_message -> User message
   - event_msg payload.type == agent_message -> Assistant message
   - event_msg payload.type == agent_reasoning -> Thought message
   This avoids duplicates from response_item.message.

2) Tools and actions should come from response_item entries:
   - response_item type == function_call or custom_tool_call -> ToolCall
   - response_item type == function_call_output or custom_tool_call_output -> ToolOutput
   - These cover shell commands, apply_patch, web_search, etc.
   - Tool calls and outputs carry call_id; they should be rendered inline in order.

3) Group by user turns:
   - A "turn" starts at each user_message.
   - All subsequent items (assistant messages, thoughts, tool calls/outputs, token_count, turn_context, etc.)
     belong to that turn until the next user_message.
   - Items that appear before the first user_message should go into a special "Session Preamble" group
     (or be rendered in a session header panel).

4) Preserve order:
   - Maintain the original line order from the file. Each parsed item retains a sequence index.
   - Rendering should keep that order within each turn; toggles only hide items, not re-order them.

5) Search indexing scope:
   - Index at least user and assistant messages (event_msg) for recall.
   - Optionally index thoughts and tool outputs, but default search should prioritize user/assistant.

Data Model (Front-end)
- SessionFile:
  - id: string (relative path from sessions root)
  - dateParts: { year, month, day }
  - filename, fullPath, sizeBytes, timestampFromName
- ParsedItem (union):
  - type: 'user' | 'assistant' | 'thought' | 'tool_call' | 'tool_output' | 'token_count' | 'meta'
  - content: string (or structured fields)
  - raw: object (original JSON) for optional detail panels
  - callId (for tool_call/tool_output)
  - seq: number (line index)
  - timestamp (if present)
- Turn:
  - id: number
  - startedAt: timestamp (from user_message line if present)
  - items: ParsedItem[] (ordered)

Backend Architecture (Vite Dev Server Middleware)
- Add a middleware layer in `vite.config.ts` (configureServer) or a small module imported by it.
- Use Node fs/promises + path to scan the sessions root.
- Introduce a persistent config file (server-side) to store the chosen sessions root:
  - Default root: ~/.codex/sessions
  - Env override: CODEX_SESSIONS_ROOT
  - Optional config file: ~/.codex-formatter/config.json with { sessionsRoot: "..." }

API Endpoints
1) GET /api/sessions
   - Returns a tree of sessions grouped by year/month/day.
   - Each file entry includes relative path, size, parsed timestamp from filename, and preview data (optional).
   - Example response:
     {
       "root": "/Users/.../.codex/sessions",
       "years": [
         {
           "year": "2026",
           "months": [
             { "month": "01", "days": [
               { "day": "21", "files": [
                 { "id": "2026/01/21/rollout-2026-01-21T...jsonl", "size": 12345, "preview": "hi how are you" }
               ]}
             ]}
           ]
         }
       ]
     }

2) GET /api/session?path=<relative-path>
   - Returns raw JSONL for the requested file.
   - Validate that the resolved path is within sessions root.
   - Reject traversal attempts (".." or resolved path outside root).

3) GET /api/search?q=<term>&limit=<n>
   - Queries SQLite FTS and returns matching messages with session info and snippets.
   - Result items include: session path, turn id, role, snippet, timestamp, and optional score.

4) POST /api/reindex
   - Rebuild or refresh the SQLite index.
   - Returns progress summary (#files scanned, #messages indexed).

5) GET /api/config
   - Returns current sessions root.

6) POST /api/config
   - Update sessionsRoot in server config file and trigger rescan/reindex.
   - Validate absolute path and ensure it exists/readable.

SQLite Indexing (Server-side)
- Use SQLite with FTS5 for fast full-text search.
- Suggested structure:
  - sessions table:
    - id (pk), path, timestamp, cwd, git_branch, git_repo, first_user_message
  - files table:
    - path (primary key), size, mtime, hash, indexed_at
  - messages table:
    - id (pk), session_id (fk), turn_id, role, timestamp, content
  - messages_fts (FTS5 virtual table) for content + metadata columns
- Indexing strategy:
  - On server start or POST /api/reindex, scan sessions root.
  - For each file, compare size/mtime (or hash) to detect changes.
  - If changed or new, parse JSONL and (re)insert messages + update session metadata.
  - Delete rows for removed files.
- DB location:
  - Store in user data: ~/.codex-formatter/codex_index.db (avoid polluting repo).

React Markdown Rendering
- Add dependencies:
  - react-markdown
  - remark-gfm (tables/strikethrough/task lists)
  - rehype-sanitize (recommended to avoid unsafe HTML)
  - react-syntax-highlighter (optional, for code blocks)
- Rendering approach:
  - Use <ReactMarkdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeSanitize]}>
  - Disable raw HTML by default; allow only safe formatting.
  - Add custom components for code blocks and inline code for styling consistency.
- Preserve original markdown string for copy-as-markdown.
- For copy-as-text, derive plain text:
  - Option A: use strip-markdown
  - Option B: render to a hidden element and use its innerText
  - Prefer Option A for deterministic output.

Per-Message Copy Buttons
- Add two buttons at the top-right of each message block:
  - Copy as text: plain text (markdown stripped)
  - Copy as markdown: raw original content
- Apply to user/assistant/thought items. For tool blocks, either:
  - Provide copy buttons too (copies raw JSON or formatted tool text), or
  - Provide a single copy action for tool items.

UI/UX Changes
- Layout:
  - Split layout: left sidebar for session browsing + search, main panel for conversation view.
  - Expand main panel width (e.g. max-w-6xl or full width with comfortable padding).

- Sidebar:
  - Search input at top; results list below.
  - Session browser tree (Year -> Month -> Day -> File list) below search or in a tab.
  - Clicking a search result opens its session and scrolls to the matching turn.
  - Add a Settings modal for sessions root path and reindex action.

- Viewer Toggles (default ON for thoughts/tools):
  - Show Thoughts
  - Show Tools/Actions
  - Optional: Show Metadata (turn_context, token_count, session_meta)
  - Show Full Content (keep existing behavior)

- Turn Grouping Visuals:
  - Each user turn rendered as a grouped card/section.
  - Inside each group: user -> thoughts -> tools -> assistant, all inline in chronological order.
  - Add visual separators and a light background to clarify the grouping.

Rendering Details (Inline Tools)
- Within each turn, render items in sequence order.
- Tool call block should show:
  - Tool name (e.g. shell_command, apply_patch, web_search)
  - Arguments/input (collapsed by default if large)
  - call_id
- Tool output block should show:
  - Output text or JSON
  - call_id
- This preserves causal flow: thought -> tool_call -> tool_output -> assistant response.

Copy / Export Behavior (Conversation-wide)
- Respect visibility toggles: only visible item types are included in copied text.
- Preserve existing XML-like format for user/assistant/thought messages.
- Add explicit tags for tools, e.g.:
  - <TOOL-CALL-n name="shell_command" call_id="...">...</TOOL-CALL-n>
  - <TOOL-OUTPUT-n call_id="...">...</TOOL-OUTPUT-n>
- Keep the outer <CONVERSATION-ID> wrapper unchanged.

Error Handling and Resilience
- Parsing:
  - Ignore blank lines.
  - On JSON.parse failure, record a parse error with line number; continue parsing.
- Display:
  - Show a non-blocking error banner listing parse issues.
  - If no user_message found, show a friendly empty state.
- API:
  - If root does not exist, return a clear error explaining how to set CODEX_SESSIONS_ROOT
    or update ~/.codex-formatter/config.json.

Performance Considerations
- Do not parse the entire sessions tree on every render; only on refresh or initial load.
- JSONL parsing should be line-based and linear.
- Indexing can be done incrementally based on file mtime/size.
- For very large files, consider virtualization for rendering later.

Testing/Validation Checklist
- Load a known session file and verify:
  - User and assistant messages render in correct order.
  - Thoughts and tools appear inline between messages.
  - Toggling thoughts/tools hides and shows the correct items.
  - Tool calls and outputs display in the correct order and with correct call_id.
  - No duplicate messages from response_item.message.
- Verify search:
  - Indexing picks up user/assistant content.
  - Searching "react-markdown" returns a session where it appears.
  - Search result opens the session and scrolls to the matching turn.
- Verify path traversal protection:
  - /api/session?path=../secrets should be rejected.
- Verify environment override:
  - Set CODEX_SESSIONS_ROOT and ensure /api/sessions scans that path.

Implementation Order (Suggested)
1) Add server middleware with /api/sessions and /api/session endpoints.
2) Add SQLite indexing (schema + /api/reindex + /api/search).
3) Build sidebar UI: search + session tree + settings modal.
4) Implement parser and turn-grouping logic with inline ordering.
5) Integrate react-markdown + syntax highlighting + per-message copy buttons.
6) Update global copy/export and toggles (thoughts/tools/default on).
7) Expand conversation container width and refine visuals.
8) Add error handling, empty states, and refresh controls.

Notes
- Keep sessions separate; do not merge across files.
- Preserve chronological order as recorded in the JSONL.
- Inline tools are required to maintain reasoning -> tool usage flow.
- SQLite DDL and UI wireframes live in `DESIGN_APPENDIX.txt`.
