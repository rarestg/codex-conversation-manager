Implementation Plan — Best Fix for Copy Lag and Re-render Churn

Context

We are solving a UX/performance problem: copy buttons (session ID, filename, message copy, etc.) cause noticeable lag. The copy operation itself is fast, but the UI re-renders large, expensive subtrees on every copy state change. Investigation logs confirm this: top-level `copiedId` state in ConversationViewer triggers a full page render, and heavy components (`Sidebar`, `SessionsPanel`, `TurnList`) each take hundreds of milliseconds to render. That cost is incurred twice (on “copied” and on clearing), which matches the user’s delay.

This plan implements the **best long-term fix**: localize copy feedback state, structurally isolate heavy panels from copy state, and only add memoization after re-profiling. The goal is clean, maintainable code, not a blanket “memo everything” approach.

Relevant code and data flow

- `src/features/conversation/ConversationViewer.tsx` currently owns `copiedId` and passes it down to `SessionHeader` and `TurnList` (which passes to every `MessageCard`). This makes copy actions a top-level state change and triggers full page re-render.
- `src/features/conversation/components/SessionHeader.tsx` uses `copiedId` to display checkmarks in session meta chips and copy conversation button.
- `src/features/conversation/components/MessageCard.tsx` uses `copiedId` for per-message “Copied” state.
- `src/features/conversation/components/TurnList.tsx` renders all conversation cards and is expensive.
- `src/features/conversation/components/SessionsPanel.tsx` renders a large tree of sessions and is expensive.
- `src/features/conversation/components/Sidebar.tsx` holds search + sessions panels; expensive when SessionsPanel re-renders.
- `src/features/conversation/hooks/useCopyFeedback.ts` currently provides global `copiedId` and `showCopied` used by ConversationViewer.
- Debug logging was added during the investigation; it should be removed after the fix is validated.

The architectural change is twofold:
1) Localize copy feedback state so copy actions do not trigger full-tree renders.
2) Structure the component tree to isolate Sidebar from copy state even before memoization.

The Plan

Step 1: Split ConversationViewer into Sidebar + ConversationMain siblings

Where:
- `src/features/conversation/ConversationViewer.tsx`
- New file: `src/features/conversation/ConversationMain.tsx`

What to do:
- Extract the main content area (SessionHeader + TurnList + copy handlers) into a new `ConversationMain` component.
- `ConversationViewer` should render `<Sidebar />` and `<ConversationMain />` as siblings.
- Only `ConversationMain` should own copy state. Sidebar must not receive copy-related props or state.

Why:
- Structural isolation means copy state changes can no longer trigger Sidebar/SessionsPanel re-renders. This alone removes the largest lag source.

Dependencies:
- This step should happen before moving copy state down so we can keep responsibilities clear.

Step 2: Introduce a localized CopyButton (preferred) or local copy hook

Where:
- Preferred: new component `src/features/conversation/components/CopyButton.tsx`
- Alternative: use `useCopyFeedback` inside `SessionHeader` and `MessageCard` directly.

What to do:
- Create a small `CopyButton` that owns its own copied state (internally uses `useCopyFeedback` or a local `useState`).
- `CopyButton` should accept:
  - `onCopy: () => Promise<void> | void`
  - `label` (default text)
  - `copiedLabel` (optional, default “Copied”)
  - optional `duration` for feedback
  - optional `aria-label` / `title`
- On click:
  - await the copy operation
  - show “Copied” locally for a short duration

Why:
- Copy feedback state should be as local as possible. A reusable button keeps the UI consistent and prevents future regressions.

Dependencies:
- None. This can be implemented independently.

Step 3: Move copy behavior into SessionHeader

Where:
- `src/features/conversation/components/SessionHeader.tsx`
- `src/features/conversation/ConversationMain.tsx` (if created)

What to do:
- Replace the “Copy session id”, “Copy dir”, “Copy file”, and “Copy conversation” buttons with `CopyButton` instances.
- Remove `copiedId`, `onCopyMeta`, and `onCopyConversation` props from `SessionHeader`.
- If `ConversationMain` still provides a shared `handleCopyConversation` function, pass it down; otherwise keep logic local to SessionHeader.

Why:
- Keeps header feedback isolated so a chip copy doesn’t re-render the message list or sidebar.

Dependencies:
- Step 2 must be done first.

Step 4: Move copy behavior into MessageCard

Where:
- `src/features/conversation/components/MessageCard.tsx`
- `src/features/conversation/components/TurnList.tsx`

What to do:
- Replace the per-message copy buttons with `CopyButton` instances.
- Remove `copiedId` and `onCopyItem` props from `TurnList` and `MessageCard`.
- Ensure `markdownToPlainText` is called locally for “Copy text”.

Why:
- Prevents message copy from re-rendering every message card.

Dependencies:
- Step 2 must be done first.

Step 5: Re-profile before adding memoization

Where:
- React DevTools Profiler
- (Optional) temporarily keep lightweight logging from `useRenderDebug`

What to do:
- After Steps 1–4, test copy actions again.
- If Sidebar/SessionsPanel no longer re-render on copy, memoization is likely unnecessary for this bug.
- Only add memoization if profiling shows continued unnecessary re-renders.

Why:
- Avoids “memo everywhere” and keeps the codebase clean.

Dependencies:
- Steps 1–4 must be complete to accurately measure the new behavior.

Step 6: If needed, add targeted memoization (cleanly)

Where:
- `src/features/conversation/components/Sidebar.tsx`
- `src/features/conversation/components/SessionsPanel.tsx`
- `src/features/conversation/components/TurnList.tsx`
- (Optional) `src/features/conversation/components/WorkspacesPanel.tsx`

What to do:
- Memoize only the components that still re-render unnecessarily after Step 5.
- Ensure callback props are stable (`useCallback`) before memoization; otherwise memoization is ineffective.
- Use a clean memo style:
  - Define component normally, then export `React.memo(Component)`.
  - Avoid large inline `memo(() => ...)` blocks.

Why:
- Keeps memo usage minimal and readable while still protecting performance.

Dependencies:
- Step 5 (profiling) must show a real need for memoization.

Step 7: Remove investigation logging and restore StrictMode

Where:
- `src/features/conversation/hooks/useRenderDebug.ts`
- `src/features/conversation/hooks/useWhyDidYouRender.ts`
- All components that reference them
- `src/features/conversation/components/MessageCard.tsx` (remove debug console)
- `src/features/conversation/hooks/useCopyFeedback.ts` (remove debug console)
- `src/main.tsx` (re-enable StrictMode)

What to do:
- Remove all investigation-only logging.
- Restore `<React.StrictMode>` in `src/main.tsx`.

Why:
- Logging is for diagnosis only; StrictMode should remain on in development.

Dependencies:
- Do this last, after the fix has been validated.

Decisions & Tradeoffs

Chosen approach: Localize copy feedback state + structural isolation + targeted memoization only if needed.

Why this approach:
- Local state prevents unrelated re-renders by design.
- Structural separation ensures Sidebar is unaffected by copy state even before memoization.
- Memoization becomes a surgical tool instead of scattered optimization noise.

Alternatives considered:
- “Minimal fix” by stabilizing handlers only. Not sufficient because global `copiedId` still triggers a full render.
- Global external store with fine-grained subscriptions. Overkill; local UI state is simpler and more idiomatic.

Tradeoffs accepted:
- Slightly more components (`ConversationMain`, `CopyButton`) in exchange for dramatically improved responsiveness.
- Local “Copied” indicators can appear simultaneously in multiple places (acceptable and consistent with UX).

Landmines & Non‑obvious Notes

- Do not leave `copiedId` in ConversationViewer. Even with memoization, the top-level state change will still force a render of the entire tree.
- If memoization is added, ensure props are stable. Memoizing with unstable callbacks is ineffective and misleading.
- Do not keep logging hooks after finishing; they distort performance and clutter logs.
- `markdownToPlainText` is async and relatively small (~10ms). The real issue is render cost.
- StrictMode must be re-enabled once debugging is complete; leaving it off hides issues.

Verification

Functional checks:
1. Run the app (`npm run dev`).
2. Load a session, click “Copy session id.”
   - The “Copied” indicator should appear immediately.
   - Sidebar should not re-render.
3. Copy a message as text and markdown.
   - Only the local message card should re-render.
   - No full list repaint or large main-thread spikes.
4. Ensure search, workspace filtering, and session selection still work.

Performance checks:
- React Profiler should show the copy action re-rendering only the local button/card/header.
- No `[Violation] 'message' handler` spikes on copy in normal use.

Regression checks:
- Session header copy actions still work and copy correct values.
- Copy conversation still works.
- StrictMode warnings (if any) are addressed after re-enabling StrictMode.

