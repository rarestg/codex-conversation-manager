MessageCard Renderer Refactor (Handoff-Ready Plan)

Context
We are refactoring the conversation item renderer to remove a large, branch-heavy MessageCard component and replace it with a small dispatcher + per-type renderers. This is a cleanup that became necessary after token_count was split into its own dedicated renderer (TokenCountCard). The current MessageCard short-circuits token_count with an early return, which makes token_count branches in the remaining code unreachable and triggers type narrowing errors in TypeScript. The immediate goal is to remove unreachable branches and clarify responsibilities: each ParsedItem type owns its label, tone, copy actions, and body rendering.

Where this fits in the codebase
- Parsed items are produced by `src/features/conversation/parsing.ts` and routed into the UI through `TurnList -> TurnCard -> MessageCard`.
- MessageCard currently handles labels, tone classes, copy buttons, and markdown vs. JSON rendering for all types (user/assistant/thought/tool_call/tool_output/meta/token_count).
- TokenCountCard already exists as a specialized renderer, and MessageCard now early-returns to TokenCountCard for token_count items.
- Copy behavior uses `CopyButton` and `markdownToPlainText` for markdown items.
- Truncation is controlled by `MAX_PREVIEW_CHARS` and `showFullContent`.
- This refactor does not touch parsing, indexing, or filtering; it only changes rendering internals.

Problem
The current MessageCard mixes multiple responsibilities and now contains unreachable branches for token_count, creating typecheck errors and increasing cognitive load. It is harder to reason about per-type rendering, and changes to one type risk impacting others. The refactor aims to isolate rendering behavior by type and keep MessageCard as a small dispatcher.

Plan (execution order)

1) Introduce a shared base component for the common layout
What to do:
- Create `src/features/conversation/components/BaseMessageCard.tsx`.
- This component should render the shared wrapper structure (rounded card, stagger animation, header row, body container) but accept slots for:
  - Role label text
  - Optional tool/call metadata
  - Action buttons (copy actions)
  - Body content
Where and why:
- All non-token_count items share the same wrapper structure and animation. Centralizing that avoids repetitive markup and keeps layout consistent.
Dependencies:
- This must be created before per-type renderers can use it.

2) Create per-type renderer components
What to do:
- Create renderer components for each non-token_count type:
  - `UserMessageCard.tsx`
  - `AssistantMessageCard.tsx`
  - `ThoughtMessageCard.tsx`
  - `ToolCallCard.tsx`
  - `ToolOutputCard.tsx`
  - `MetaCard.tsx`
- Each renderer:
  - Supplies its own role label (e.g., “User”, “Tool Call”) and tone classes.
  - Provides the appropriate copy buttons:
    - Markdown items: “Copy text” + “Copy MD”.
    - Tool/meta items: “Copy”.
  - Renders body content in either MarkdownBlock (for user/assistant/thought) or preformatted JSON/text (for tool/meta).
  - Handles toolName/callId display in the header for tool_call/tool_output only.
Where and why:
- These go under `src/features/conversation/components/` to keep cohesion with current UI components.
- This isolates per-type behavior, making it easier to change one without affecting others.
Dependencies:
- BaseMessageCard should exist so these renderers can be kept minimal.

3) Convert MessageCard into a dispatcher
What to do:
- Keep `MessageCard.tsx` as a small dispatcher:
  - Define a typed map of renderers keyed by ParsedItem.type.
  - Resolve the renderer and return `<Renderer item={item} itemIndex={itemIndex} showFullContent={showFullContent} />`.
- Ensure token_count routes to the existing TokenCountCard.
Where and why:
- This makes MessageCard trivial and eliminates branching and unreachable logic.
Dependencies:
- All per-type renderers must exist before the dispatcher is wired.

4) Migrate shared helpers
What to do:
- Extract any shared helper logic used by multiple renderers (e.g., truncation, markdown-to-plain-text) into BaseMessageCard or a small helper file if needed.
- Ensure `showFullContent` behavior is identical to current MessageCard (same truncation thresholds).
Why:
- This maintains output parity and avoids subtle differences between type renderers.

5) Remove unreachable logic from MessageCard
What to do:
- After dispatcher is in place, delete the old branching logic and token_count label/tone branches.
- Ensure there are no unused imports (e.g., MarkdownBlock, CopyButton, MAX_PREVIEW_CHARS) if these move to per-type components.
Why:
- Keeps the dispatcher lean and resolves TypeScript narrowing errors.

6) Wire exports/imports and verify usage
What to do:
- Update any references to MessageCard if its imports change (should remain same public API).
- Ensure no new public API changes are introduced; callers (TurnCard) remain unchanged.

Decisions & tradeoffs
- Chosen approach: dispatcher + per-type renderers + shared base layout.
  - Pros: clearer ownership, easy to extend, TypeScript narrowing issues resolved, better testability.
  - Cons: more files, small boilerplate overhead.
- Alternative: keep a single MessageCard with a switch statement.
  - Pros: fewer files.
  - Cons: still centralizes everything; harder to reason about and more likely to regress.
- Alternative: create only TokenCountCard and leave others inline.
  - Pros: minimal change.
  - Cons: leaves the codebase inconsistent and the type-narrowing issue returns for future specialized renderers.

Landmines / fragile areas
- TypeScript narrowing: If MessageCard continues to check token_count after an early return, it will fail typecheck. Ensure token_count logic lives only in TokenCountCard.
- Truncation: `showFullContent` uses MAX_PREVIEW_CHARS; do not change this logic or copy behavior will diverge from current UX.
- Copy actions: Markdown items must use markdownToPlainText for “Copy text” and raw content for “Copy MD”; tools/meta should copy raw content only.
- Tool metadata: tool_call/tool_output rely on toolName/callId display; avoid dropping those labels when moving code.

Verification
- Visual parity check (manual):
  - Load a session with user, assistant, thought, tool_call, tool_output, and meta items.
  - Confirm labels, colors, and spacing match prior behavior.
  - Confirm token_count still uses TokenCountCard.
- Copy behavior:
  - Verify “Copy text” and “Copy MD” for user/assistant/thought behave the same as before.
  - Verify “Copy” for tool/meta yields the raw JSON/text content.
- Truncation:
  - Toggle Full content and confirm truncation behavior is unchanged.
- Typecheck:
  - Run `npm run typecheck` to confirm the TS2367 error is resolved and no new type errors appear.

Notes
- This refactor should not alter parsing, indexing, filtering, or toggle behavior. It is purely UI rendering cleanup.
- If you want to keep file proliferation down, you can group the per-type renderers into a `components/messageCards/` folder and re-export them from an index.
