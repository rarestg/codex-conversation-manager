Context

We want to refactor the backend logic that currently lives in a large file so the codebase is easier to understand, test, and evolve. Right now, server behavior, SQLite indexing, JSONL parsing, and API routing are all implemented in a single module (currently server/apiPlugin.ts). This makes it hard to reason about responsibilities, creates large files that are awkward to review, and makes unit testing difficult because pure logic is tangled with Vite middleware and database setup. The goal is not to change behavior but to make the server code modular and testable while keeping the Vite config simple and the API surface unchanged.

Why now: the server code has grown to hundreds of lines, and new contributors struggle to navigate it. The project has also recently cleaned up linting/typechecking; this refactor is a natural next step to improve maintainability without altering product behavior.

Relevant codebase areas and how they connect:
- server/apiPlugin.ts: Contains all backend logic for config handling, DB access, scanning JSONL files, building session trees, and Vite middleware for REST endpoints.
- vite.config.ts: Very small; imports apiPlugin from server/apiPlugin.ts and registers it with Vite plugins.
- Frontend APIs: src/features/conversation/api.ts calls endpoints served by apiPlugin (e.g., /api/sessions, /api/search). Any change must preserve these endpoints and response shapes.
- Data conventions: parsing of JSONL entries is used to index messages and to build session preview metadata.

The refactor must preserve the existing API responses, file scanning behavior, indexing behavior, and configuration semantics (e.g., CODEX_SESSIONS_ROOT override, config file, DB path). No behavior changes are intended.

The Plan

Overview: Split server/apiPlugin.ts into 5–6 focused modules under /server without changing runtime behavior. Keep the API route wiring in apiPlugin.ts, but move configuration logic, DB logic, indexing logic, and HTTP utility functions to separate files. Centralize shared types in server/types.ts. The end result should keep the Vite config unchanged except for imports, and keep the frontend API contract identical.

Step 1 — Create server/types.ts for shared interfaces
What to do: Create /server/types.ts and move shared interfaces into it. At minimum, define and export:
- ConfigFile (sessionsRoot?: string)
- FileEntry (absPath, relPath, size, mtimeMs)
- SessionFileInfo (id, filename, size, preview, timestamp, cwd)
- Any small helper types needed by indexer functions (e.g., PreviewMap type)
Why: Centralized types avoid circular imports and make type reuse explicit between config, DB, and indexer modules.
Dependencies: None. This file should be created before moving code into modules that need these types.

Step 2 — Extract config logic to server/config.ts
What to do: Create /server/config.ts and move the following from server/apiPlugin.ts:
- CONFIG_DIR, CONFIG_PATH, DEFAULT_SESSIONS_ROOT
- cachedConfig/cachedRoot variables
- ensureDir, readConfigFile, writeConfigFile
- resolveSessionsRoot, setSessionsRoot
Use types from server/types.ts. Ensure exports are explicit (export const resolveSessionsRoot, setSessionsRoot, etc.).
Why: Configuration is cohesive and low‑level. This split isolates IO and environment overrides from API routing and indexing logic.
Dependencies: server/types.ts

Step 3 — Extract HTTP helpers to server/http.ts
What to do: Create /server/http.ts and move:
- ensurePathSafe
- readJsonBody (typed with IncomingMessage)
- sendJson (typed with ServerResponse)
Consider moving small helper functions like toPosix only if they are shared outside indexer; otherwise leave in indexer. keep these pure and minimal.
Why: These helpers are used by API handlers and should be testable without Vite. They have no dependency on DB or config.
Dependencies: None (just node:http and node:path).

Step 4 — Extract DB setup to server/db.ts
What to do: Create /server/db.ts and move:
- DB_PATH
- db variable and ensureDb
- initSchema and clearDbSchema
- Any DB-related pragmas and schema migrations
Make sure this module only exposes the DB handle and schema helpers (export ensureDb, initSchema, clearDbSchema). It can import CONFIG_DIR from config.ts or re‑compute it (preferred: import CONFIG_DIR from config.ts to keep paths consistent).
Why: DB initialization should be separate from scanning and routing. Keeping the schema logic in one place simplifies future migrations.
Dependencies: server/config.ts (for CONFIG_DIR/DB path), server/types.ts (if needed), better-sqlite3.

Step 5 — Extract indexing + parsing to server/indexer.ts
What to do: Create /server/indexer.ts and move all indexing/scanning/parsing logic, including:
- File scanning: scanSessionFiles, parseTimestampFromFilename, readFirstUserMessage
- JSONL parsing utilities: formatJsonValue, formatToolCall, formatToolOutput, normalizeSessionId, extractSessionIdFromObject, parseJsonlFile, readSessionIdFromFile
- Indexing workflow: indexSessions
- Session preview building: getSessionsPreviewMap, buildSessionsTree
Use types from server/types.ts and call ensureDb/initSchema/clearDbSchema from server/db.ts. Keep helper functions private unless used by tests.
Why: This is the largest and most testable chunk. Extracting it makes it possible to add unit tests without Vite middleware.
Dependencies: server/types.ts, server/db.ts, server/config.ts (if needed for paths), node:fs, node:readline, node:path.

Step 6 — Update server/apiPlugin.ts to be a thin router
What to do: Replace the bulk of server/apiPlugin.ts with a Vite plugin that imports and uses the new modules:
- Import resolveSessionsRoot/setSessionsRoot from config.ts
- Import ensureDb/initSchema/clearDbSchema from db.ts
- Import scanSessionFiles, indexSessions, getSessionsPreviewMap, buildSessionsTree, readFirstUserMessage from indexer.ts
- Import ensurePathSafe, readJsonBody, sendJson from http.ts
Keep the route handlers inline (no routes/ directory for now). Ensure endpoints and payloads are unchanged.
Why: Keeps the Vite integration simple and readable while delegating heavy logic to dedicated modules.
Dependencies: All the new server modules.

Step 7 — Update imports and run checks
What to do: Update any import paths in vite.config.ts or other files if needed. Run:
- npm run check
- npm run typecheck
- npm run mdlint
Why: Verify that type boundaries and linting still pass after the refactor.
Dependencies: All prior steps.

Decisions & Tradeoffs

Chosen approach: Middle‑ground modularization (types.ts, config.ts, http.ts, db.ts, indexer.ts, apiPlugin.ts). This balances clarity with minimal indirection.

Alternatives considered:
- Full route splitting (server/routes/…): Rejected for now because the API surface is small and additional indirection would slow comprehension without clear benefit.
- Leave db and indexer together: Considered, but keeping db.ts separate allows clearer schema management and keeps indexer focused on workflow. The indexer can still import db.ts and remain cohesive without passing DB handles everywhere.
- Minimal refactor (only extract pure parsing functions): Too little gain relative to the clear maintainability win of the middle‑ground split.

Tradeoffs accepted:
- More files to navigate, but each is shorter and cohesive.
- Some coupling remains between indexer and db, which is acceptable for now.
- Slight refactor overhead now to avoid repeated “large file” maintenance costs later.

Landmines

- API contract stability: The frontend relies on exact response shapes from /api/* endpoints. Any field renaming or response changes will break the UI. Do not change field names or response structure.
- Path safety: ensurePathSafe is security‑sensitive. Keep the logic intact; do not alter normalization or the check for traversal (..). It protects file access.
- Config resolution precedence: resolveSessionsRoot must preserve the order env > config > default. Do not invert the precedence.
- Database schema migrations: initSchema modifies tables if columns are missing. Preserve this logic; avoid “simplifying” it away or you risk breaking existing users’ local DB.
- JSONL parsing: The parsing rules are subtle and match Codex session formats. Keep the handling of event_msg vs response_item types unchanged.
- buildSessionsTree ordering: The sort order is important to how sessions display. Preserve descending sorting by year/month/day and filename ordering.
- Vite plugin behavior: Only dev server uses the API middleware. If you add apply: 'serve', ensure it matches current behavior (currently it runs in dev only). Don’t break builds.

Failed approaches already tried:
- Over‑splitting into routes/ directories was deemed unnecessary overhead.
- The earlier “all in one file” approach is what we’re refactoring away from due to maintainability and testability concerns.

Verification

After each major step:
- Step 1–5: Run TypeScript checks to ensure types and imports are correct:
  - npm run typecheck
- Step 6: Verify the dev server still responds to endpoints:
  - npm run dev, then request /api/config, /api/sessions, /api/search from the UI or curl.
- Final: Run the full set of checks:
  - npm run check
  - npm run typecheck
  - npm run mdlint

Manual functional checks:
- Open the app, ensure session list loads, search works, session previews render, and reindex/clear index works.
- Change sessions root via Settings to ensure config writes/read still function.
- Confirm session deep links still resolve and load.

If any errors occur, rollback by temporarily re‑inlining the affected module into apiPlugin.ts and re‑run checks to localize the issue.
